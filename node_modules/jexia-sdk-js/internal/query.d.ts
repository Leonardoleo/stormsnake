import { IFilteringCriterion, IFilteringCriterionCallback } from "../api/core/filteringApi";
import { QueryActionType, QueryParam } from "./utils";
export declare type Direction = "asc" | "desc";
declare type KeyOfObject<T> = Extract<keyof T, string>;
export interface IAggField<T = any> {
    fn: "count" | "min" | "max" | "avg" | "sum";
    field: KeyOfObject<T> | "*";
    alias?: string;
}
export interface ICompiledAggField {
    [key: string]: string;
}
interface ISort<K> {
    fields: K[];
    direction: Direction;
}
declare type SortedFields<T> = Array<ISort<KeyOfObject<T>>>;
export interface ICompiledQuery<T> {
    action: QueryActionType;
    action_resource: string;
    action_cond: object[];
    cond: object[];
    outputs: Array<string | ICompiledAggField>;
    order: SortedFields<T>;
    range: {
        limit?: number;
        offset?: number;
    };
    relations: {
        [key: string]: Partial<ICompiledQuery<T>>;
    };
}
export declare class Query<T = any> {
    fields: Array<KeyOfObject<T> | IAggField<T>>;
    limit: number;
    offset: number;
    private filteringConditions;
    private orders;
    private actionParams;
    setFilterCriteria(filter: IFilteringCriterion<T> | IFilteringCriterionCallback<T>): void;
    addSortCondition<K extends Extract<keyof T, string>>(direction: Direction, ...fields: K[]): void;
    setAction(action: QueryActionType, actionResource: string, filter: IFilteringCriterion<T> | IFilteringCriterionCallback<T>): void;
    compile(): Partial<ICompiledQuery<T>>;
    compileToQueryParams(): QueryParam[];
    private compileAggregation;
}
export {};
