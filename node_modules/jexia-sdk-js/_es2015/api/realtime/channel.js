import { from, Observable } from "rxjs";
import { RequestExecuter } from "../../internal/executer";
import { Query } from "../../internal/query";
import { RequestMethod } from "../../internal/requestAdapter.interfaces";
import { ResourceType } from "../core/resource";
import { RealTimeCommandTypes } from "./realTime.interfaces";
import { realTimeCommand, subscribeEventMessage, unsubscribeEventMessage, wsReadyDefer } from "./websocket";
export class Channel extends Observable {
    constructor(injector, websocketFactory, name) {
        super((observer) => {
            wsReadyDefer.promise
                .then(() => subscribeEventMessage(this.websocketFactory(), ["published"], name, ResourceType.Channel, observer))
                .catch((error) => observer.error(error));
            return () => wsReadyDefer.promise
                .then(() => unsubscribeEventMessage(this.websocketFactory(), ["published"], name, ResourceType.Channel, observer)
                .catch(() => undefined));
        });
        this.injector = injector;
        this.websocketFactory = websocketFactory;
        this.name = name;
    }
    publish(data) {
        return from(wsReadyDefer.promise.then(() => {
            return realTimeCommand(this.websocketFactory(), {
                command: RealTimeCommandTypes.Publish,
                correlation_id: Math.random().toString(),
                arguments: { channel: this.name, data },
            });
        }));
    }
    getLog(filter) {
        const query = new Query();
        if (filter) {
            query.setFilterCriteria(filter);
        }
        const requestExecutor = this.injector.get(RequestExecuter);
        return requestExecutor.executeRequest({
            resourceType: ResourceType.Channel,
            resourceName: this.name,
            method: RequestMethod.GET,
            body: {},
            queryParams: query.compileToQueryParams()
        });
    }
}
