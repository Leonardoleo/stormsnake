import { API, MESSAGE } from "../../config";
import { RequestExecuter } from "../../internal/executer";
import { AuthOptions, TokenManager } from "../core/tokenManager";
import { Dataset } from "../dataops/dataset";
import { Fileset } from "../fileops/fileset";
import { Channel } from "./channel";
import { WebSocketState } from "./realTime.interfaces";
import { watch } from "./watch";
import * as websocket from "./websocket";
const RTCResources = [Dataset, Fileset];
export class RealTimeModule {
    constructor(websocketBuilder) {
        this.websocketBuilder = websocketBuilder;
    }
    init(coreInjector) {
        this.injector = coreInjector.resolveAndCreateChild([
            RequestExecuter,
        ]);
        const tokenManager = coreInjector.get(TokenManager);
        const { projectID } = coreInjector.get(AuthOptions);
        RTCResources.forEach((resource) => resource.prototype.watch = watch);
        return tokenManager.token().toPromise().then((token) => {
            try {
                this.websocket = this.websocketBuilder(this.buildSocketOpenUri(projectID, token));
            }
            catch (error) {
                throw new Error(`${MESSAGE.RTC.ERROR_CREATING_WEBSOCKET} Original error: ${error.message}`);
            }
            if (!this.websocket) {
                throw new Error(MESSAGE.RTC.BAD_WEBSOCKET_CREATION_CALLBACK);
            }
            RTCResources.forEach((resource) => resource.prototype.webSocket = this.websocket);
            return new Promise((resolve, reject) => {
                this.websocket.onopen = resolve;
                this.websocket.onerror = () => reject(new Error(MESSAGE.RTC.CONNECTION_FAILED));
            });
        })
            .then(() => websocket.start(this.websocket, () => tokenManager.token().toPromise()))
            .then(() => this);
    }
    getConfig() {
        return { rtc: {} };
    }
    channel(name) {
        return new Channel(this.injector, () => this.websocket, name);
    }
    terminate() {
        if (this.websocket.readyState === WebSocketState.CLOSED) {
            return Promise.resolve(this);
        }
        return new Promise((resolve, reject) => {
            this.websocket.onclose = () => resolve(this);
            this.websocket.onerror = (err) => reject(err);
            this.websocket.close();
        });
    }
    buildSocketOpenUri(projectID, token) {
        const result = `${API.REAL_TIME.PROTOCOL}://${projectID}.${API.HOST}.${API.DOMAIN}` +
            `${API.REAL_TIME.PORT || ""}${API.REAL_TIME.ENDPOINT}?access_token=${token}`;
        return result;
    }
}
