import { CompositeFilteringCondition, FilteringCondition } from "./filteringCondition";
export class FieldFilter {
    constructor(fieldName) {
        this.fieldName = fieldName;
    }
    isGreaterThan(value) {
        return new FilteringCriterion(new FilteringCondition(this.fieldName, ">", value));
    }
    isLessThan(value) {
        return new FilteringCriterion(new FilteringCondition(this.fieldName, "<", value));
    }
    isEqualTo(value) {
        return new FilteringCriterion(new FilteringCondition(this.fieldName, "=", value));
    }
    isDifferentFrom(value) {
        return new FilteringCriterion(new FilteringCondition(this.fieldName, "!=", value));
    }
    isEqualOrGreaterThan(value) {
        return new FilteringCriterion(new FilteringCondition(this.fieldName, ">=", value));
    }
    isEqualOrLessThan(value) {
        return new FilteringCriterion(new FilteringCondition(this.fieldName, "<=", value));
    }
    isNull() {
        return new FilteringCriterion(new FilteringCondition(this.fieldName, "null", true));
    }
    isNotNull() {
        return new FilteringCriterion(new FilteringCondition(this.fieldName, "null", false));
    }
    isInArray(values) {
        return new FilteringCriterion(new FilteringCondition(this.fieldName, "in", values));
    }
    isNotInArray(values) {
        return new FilteringCriterion(new FilteringCondition(this.fieldName, "not in", values));
    }
    isLike(value) {
        return new FilteringCriterion(new FilteringCondition(this.fieldName, "like", value));
    }
    satisfiesRegexp(regexp) {
        return new FilteringCriterion(new FilteringCondition(this.fieldName, "regex", regexp));
    }
    isBetween(start, end) {
        return new FilteringCriterion(new FilteringCondition(this.fieldName, "between", [start, end]));
    }
}
export class FilteringCriterion {
    constructor(lowLevelCondition, highLevelCriteria) {
        if (lowLevelCondition) {
            this.lowLevelCondition = lowLevelCondition;
        }
        if (highLevelCriteria) {
            this.lowLevelCondition = new CompositeFilteringCondition(highLevelCriteria.lowLevelCondition, "and");
        }
        if (!this.lowLevelCondition) {
            throw new Error("No information was given when constructing a FilteringCriterion.");
        }
    }
    get condition() {
        return this.lowLevelCondition;
    }
    and(conditionToAdd) {
        return new FilteringCriterion(this.lowLevelCondition.and(conditionToAdd.lowLevelCondition));
    }
    or(conditionToAdd) {
        return new FilteringCriterion(this.lowLevelCondition.or(conditionToAdd.lowLevelCondition));
    }
}
export function field(name) {
    return new FieldFilter(name);
}
export function combineCriteria(criteria) {
    return new FilteringCriterion(undefined, criteria);
}
export function toFilteringCriterion(filter) {
    return typeof filter === "function"
        ? filter((f) => new FieldFilter(f))
        : filter;
}
