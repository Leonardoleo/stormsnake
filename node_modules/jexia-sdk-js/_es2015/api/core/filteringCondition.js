import { clone } from "../../internal/utils";
export class FilteringCondition {
    constructor(field, operator, value) {
        this.field = field;
        this.operator = operator;
        this.value = value;
        this.isSingle = true;
        this.logicalOperatorType = "and";
    }
    get type() {
        return this.logicalOperatorType;
    }
    set type(type) {
        this.logicalOperatorType = type;
    }
    or(condition) {
        return new CompositeFilteringCondition(this, "and").or(condition);
    }
    and(condition) {
        return new CompositeFilteringCondition(this, "and").and(condition);
    }
    compile() {
        return [
            { field: this.field },
            this.operator,
            this.value,
        ];
    }
}
export class CompositeFilteringCondition {
    constructor(filteringCondition, logicalOperatorType) {
        this.isSingle = false;
        this.conditions = [filteringCondition];
        this.logicalOperatorType = logicalOperatorType;
    }
    get type() {
        return this.logicalOperatorType;
    }
    set type(type) {
        this.logicalOperatorType = type;
    }
    or(condition) {
        this.appendCondition(condition, "or");
        return this;
    }
    and(condition) {
        this.appendCondition(condition, "and");
        return this;
    }
    compile() {
        return this.conditions.reduce(this.toCompiledConditions, []);
    }
    toCompiledConditions(expressions, condition) {
        if (expressions.length) {
            expressions.push(condition.type);
        }
        const compiledCondition = condition.compile();
        if (condition.isSingle) {
            expressions.push(...compiledCondition);
        }
        else {
            expressions.push(compiledCondition);
        }
        return expressions;
    }
    appendCondition(condition, operator) {
        const newCondition = clone(condition);
        newCondition.type = operator;
        this.conditions.push(newCondition);
    }
}
