"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var config_1 = require("../../config");
var executer_1 = require("../../internal/executer");
var tokenManager_1 = require("../core/tokenManager");
var dataset_1 = require("../dataops/dataset");
var fileset_1 = require("../fileops/fileset");
var channel_1 = require("./channel");
var realTime_interfaces_1 = require("./realTime.interfaces");
var watch_1 = require("./watch");
var websocket = require("./websocket");
var RTCResources = [dataset_1.Dataset, fileset_1.Fileset];
var RealTimeModule = (function () {
    function RealTimeModule(websocketBuilder) {
        this.websocketBuilder = websocketBuilder;
    }
    RealTimeModule.prototype.init = function (coreInjector) {
        var _this = this;
        this.injector = coreInjector.resolveAndCreateChild([
            executer_1.RequestExecuter,
        ]);
        var tokenManager = coreInjector.get(tokenManager_1.TokenManager);
        var projectID = coreInjector.get(tokenManager_1.AuthOptions).projectID;
        RTCResources.forEach(function (resource) { return resource.prototype.watch = watch_1.watch; });
        return tokenManager.token().toPromise().then(function (token) {
            try {
                _this.websocket = _this.websocketBuilder(_this.buildSocketOpenUri(projectID, token));
            }
            catch (error) {
                throw new Error(config_1.MESSAGE.RTC.ERROR_CREATING_WEBSOCKET + " Original error: " + error.message);
            }
            if (!_this.websocket) {
                throw new Error(config_1.MESSAGE.RTC.BAD_WEBSOCKET_CREATION_CALLBACK);
            }
            RTCResources.forEach(function (resource) { return resource.prototype.webSocket = _this.websocket; });
            return new Promise(function (resolve, reject) {
                _this.websocket.onopen = resolve;
                _this.websocket.onerror = function () { return reject(new Error(config_1.MESSAGE.RTC.CONNECTION_FAILED)); };
            });
        })
            .then(function () { return websocket.start(_this.websocket, function () { return tokenManager.token().toPromise(); }); })
            .then(function () { return _this; });
    };
    RealTimeModule.prototype.getConfig = function () {
        return { rtc: {} };
    };
    RealTimeModule.prototype.channel = function (name) {
        var _this = this;
        return new channel_1.Channel(this.injector, function () { return _this.websocket; }, name);
    };
    RealTimeModule.prototype.terminate = function () {
        var _this = this;
        if (this.websocket.readyState === realTime_interfaces_1.WebSocketState.CLOSED) {
            return Promise.resolve(this);
        }
        return new Promise(function (resolve, reject) {
            _this.websocket.onclose = function () { return resolve(_this); };
            _this.websocket.onerror = function (err) { return reject(err); };
            _this.websocket.close();
        });
    };
    RealTimeModule.prototype.buildSocketOpenUri = function (projectID, token) {
        var result = config_1.API.REAL_TIME.PROTOCOL + "://" + projectID + "." + config_1.API.HOST + "." + config_1.API.DOMAIN +
            ("" + (config_1.API.REAL_TIME.PORT || "") + config_1.API.REAL_TIME.ENDPOINT + "?access_token=" + token);
        return result;
    };
    return RealTimeModule;
}());
exports.RealTimeModule = RealTimeModule;
