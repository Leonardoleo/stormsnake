var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { MESSAGE } from "../../config";
import { deferPromise } from "../../internal/utils";
import { RealTimeCommandTypes, RealTimeMessageTypes } from "./realTime.interfaces";
export const wsReadyDefer = deferPromise();
const responseStack = new Map();
const messageSubscriptions = new Map();
export const allEvents = Object.freeze(["created", "updated", "deleted"]);
export function start(webSocket, getToken) {
    webSocket.onmessage = (message) => {
        let realTimeMessage;
        try {
            realTimeMessage = JSON.parse(message.data);
        }
        catch (_) {
            throw new Error(MESSAGE.RTC.BAD_MESSAGE);
        }
        switch (realTimeMessage.type) {
            case RealTimeMessageTypes.CommandResponse:
                const response = realTimeMessage.data;
                const request = response.request;
                const callback = responseStack.get(JSON.stringify(request));
                if (callback) {
                    responseStack.delete(request);
                    callback(response);
                }
                break;
            case RealTimeMessageTypes.EventMessage:
                const eventMessage = realTimeMessage.data;
                const { action, resource: { name, type } } = eventMessage;
                const subscriptionKey = buildSubscriptionArgument([action], name, type);
                const observers = messageSubscriptions.get(JSON.stringify(subscriptionKey));
                if (observers) {
                    observers.forEach((o) => o.next(eventMessage));
                }
                else {
                    unsubscribeEventMessage(webSocket, [action], name, type);
                }
                break;
            default:
                getToken().then((token) => realTimeCommand(webSocket, {
                    command: RealTimeCommandTypes.JwtRefresh,
                    arguments: { token },
                }));
        }
    };
    wsReadyDefer.resolve();
}
export function subscribeEventMessage(webSocket, events, setName, setType, observer) {
    let subscriptionEvents = events.includes("all") ? [...allEvents] : events;
    subscriptionEvents = subscriptionEvents.filter((action) => {
        const subscriptionKey = JSON.stringify(buildSubscriptionArgument([action], setName, setType));
        const observers = messageSubscriptions.get(subscriptionKey);
        if (observers) {
            messageSubscriptions.set(subscriptionKey, [...observers, observer]);
            return false;
        }
        else {
            messageSubscriptions.set(subscriptionKey, [observer]);
            return true;
        }
    });
    if (!subscriptionEvents.length) {
        return Promise.resolve();
    }
    if (allEvents.every((e) => subscriptionEvents.includes(e))) {
        subscriptionEvents = ["all"];
    }
    return realTimeCommand(webSocket, buildSubscriptionCommand(RealTimeCommandTypes.Subscribe, buildSubscriptionArgument(subscriptionEvents, setName, setType)));
}
export function unsubscribeEventMessage(webSocket, events, setName, setType, observer) {
    let unsubscribeEvents = events;
    if (observer) {
        const subscriptionEvents = events.includes("all") ? allEvents : events;
        unsubscribeEvents = subscriptionEvents.filter((action) => {
            const subscriptionKey = JSON.stringify(buildSubscriptionArgument([action], setName, setType));
            const observers = (messageSubscriptions.get(subscriptionKey) || []).filter((o) => o !== observer);
            if (observers.length) {
                messageSubscriptions.set(subscriptionKey, observers);
                return false;
            }
            else {
                messageSubscriptions.delete(subscriptionKey);
                return true;
            }
        });
        if (!unsubscribeEvents.length) {
            return Promise.resolve();
        }
        if (allEvents.every((e) => unsubscribeEvents.includes(e))) {
            unsubscribeEvents = ["all"];
        }
    }
    return realTimeCommand(webSocket, buildSubscriptionCommand(RealTimeCommandTypes.UnSubscribe, buildSubscriptionArgument(unsubscribeEvents, setName, setType)));
}
function buildSubscriptionArgument(action, name, type) {
    return {
        action,
        resource: {
            type,
            name,
        },
    };
}
function buildSubscriptionCommand(command, commandArgument) {
    return {
        command,
        arguments: commandArgument,
    };
}
export function realTimeCommand(webSocket, data) {
    return new Promise((resolve, reject) => {
        const requestCommand = { type: RealTimeMessageTypes.Command, data };
        responseStack.set(JSON.stringify(requestCommand), (_a) => {
            var { error } = _a, response = __rest(_a, ["error"]);
            error ? reject(parseError(error)) : resolve(response);
        });
        sendMessage(webSocket, requestCommand);
    });
}
function sendMessage(webSocket, message) {
    try {
        webSocket.send(JSON.stringify(message));
    }
    catch (error) {
        if (error.message === MESSAGE.RTC.NOT_OPEN_ERROR) {
            throw new Error(MESSAGE.RTC.NOT_OPEN_MESSAGE);
        }
        throw new Error(error);
    }
}
function parseError(error) {
    if (error.hasOwnProperty("code")) {
        const { code, info } = error;
        return new Error(`Subscription Error: (${code}): ${info}`);
    }
    return error;
}
