var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { Injectable, InjectionToken } from "injection-js";
import { from } from "rxjs";
import { catchError, map, tap } from "rxjs/operators";
import { API, DELAY, MESSAGE } from "../../config";
import { RequestAdapter, RequestMethod } from "../../internal/requestAdapter";
import { Logger } from "../logger/logger";
import { TokenStorage } from "./componentStorage";
const APIKEY_DEFAULT_ALIAS = "apikey";
export const AuthOptions = new InjectionToken("IAuthOptions");
function notUndefined(x) {
    return x !== undefined;
}
let TokenManager = class TokenManager {
    constructor(requestAdapter, logger) {
        this.requestAdapter = requestAdapter;
        this.logger = logger;
        this.refreshes = [];
        this.defers = {};
        this.storage = TokenStorage.getStorageAPI();
    }
    get resolved() {
        return Promise.all([
            this.initPromise,
            ...Object.values(this.defers)
        ]);
    }
    token(auth) {
        return from(this.resolved).pipe(map(() => {
            const tokens = this.storage.getTokens(auth);
            if (!tokens) {
                throw new Error(MESSAGE.TokenManager.TOKEN_NOT_AVAILABLE);
            }
            return tokens.access_token;
        }));
    }
    init(opts) {
        if (!opts.projectID) {
            return Promise.reject(new Error("Please supply a valid Jexia project ID."));
        }
        this.projectId = opts.projectID;
        this.initPromise = Promise.resolve(this);
        if (opts.key && opts.secret) {
            this.initPromise = this.initPromise
                .then(() => this.login(opts).toPromise())
                .then(() => this);
        }
        return this.initPromise;
    }
    terminate() {
        this.storage.clear();
        this.refreshes.forEach((interval) => clearInterval(interval));
        this.refreshes = [];
    }
    setDefault(auth) {
        this.storage.setDefault(auth);
    }
    resetDefault() {
        this.storage.setDefault(APIKEY_DEFAULT_ALIAS);
    }
    addTokens(aliases, tokens, defaults) {
        const definedAliases = aliases.filter(notUndefined);
        definedAliases.forEach((alias, index) => {
            this.storage.setTokens(alias, tokens, !index && defaults);
        });
        this.startRefreshDigest(definedAliases);
    }
    startRefreshDigest(aliases) {
        this.refreshes.push(setInterval(() => {
            this.logger.debug("tokenManager", `refresh ${aliases[0]} token`);
            this.refresh(aliases)
                .subscribe({ error: () => this.terminate() });
        }, DELAY));
    }
    login({ auth = APIKEY_DEFAULT_ALIAS, key, secret }) {
        return this.obtainTokens(auth, this.authUrl, { method: "apk", key, secret }).pipe(tap((tokens) => this.addTokens([auth], tokens, true)));
    }
    refresh([auth, ...restAliases] = []) {
        const tokens = this.storage.getTokens(auth);
        if (!tokens || !tokens.refresh_token) {
            throw new Error(`There is no refresh token for ${auth}`);
        }
        return this.obtainTokens(auth, this.refreshUrl, { refresh_token: tokens.refresh_token }).pipe(tap((refreshedTokens) => [auth, ...restAliases].forEach((alias) => this.storage.setTokens(alias, refreshedTokens))));
    }
    obtainTokens(auth, url, body) {
        let resolve;
        this.defers[auth] = new Promise((r) => resolve = r);
        return this.requestAdapter.execute(url, {
            body,
            method: RequestMethod.POST,
        }).pipe(tap((refreshedTokens) => resolve(refreshedTokens.access_token)), catchError((err) => {
            delete this.defers[auth];
            this.logger.error("tokenManager", err.message);
            throw new Error(`Unable to get tokens: ${err.message}`);
        }));
    }
    get url() {
        return `${API.PROTOCOL}://${this.projectId}.${API.HOST}.${API.DOMAIN}:${API.PORT}`;
    }
    get authUrl() {
        return `${this.url}/${API.AUTH}`;
    }
    get refreshUrl() {
        return `${this.url}/${API.REFRESH}`;
    }
};
TokenManager = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [RequestAdapter,
        Logger])
], TokenManager);
export { TokenManager };
