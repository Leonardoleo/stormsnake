var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
import { MESSAGE } from "../../config";
import { deferPromise } from "../../internal/utils";
import { RealTimeCommandTypes, RealTimeMessageTypes } from "./realTime.interfaces";
export var wsReadyDefer = deferPromise();
var responseStack = new Map();
var messageSubscriptions = new Map();
export var allEvents = Object.freeze(["created", "updated", "deleted"]);
export function start(webSocket, getToken) {
    webSocket.onmessage = function (message) {
        var realTimeMessage;
        try {
            realTimeMessage = JSON.parse(message.data);
        }
        catch (_) {
            throw new Error(MESSAGE.RTC.BAD_MESSAGE);
        }
        switch (realTimeMessage.type) {
            case RealTimeMessageTypes.CommandResponse:
                var response = realTimeMessage.data;
                var request = response.request;
                var callback = responseStack.get(JSON.stringify(request));
                if (callback) {
                    responseStack.delete(request);
                    callback(response);
                }
                break;
            case RealTimeMessageTypes.EventMessage:
                var eventMessage_1 = realTimeMessage.data;
                var action = eventMessage_1.action, _a = eventMessage_1.resource, name_1 = _a.name, type = _a.type;
                var subscriptionKey = buildSubscriptionArgument([action], name_1, type);
                var observers = messageSubscriptions.get(JSON.stringify(subscriptionKey));
                if (observers) {
                    observers.forEach(function (o) { return o.next(eventMessage_1); });
                }
                else {
                    unsubscribeEventMessage(webSocket, [action], name_1, type);
                }
                break;
            default:
                getToken().then(function (token) { return realTimeCommand(webSocket, {
                    command: RealTimeCommandTypes.JwtRefresh,
                    arguments: { token: token },
                }); });
        }
    };
    wsReadyDefer.resolve();
}
export function subscribeEventMessage(webSocket, events, setName, setType, observer) {
    var subscriptionEvents = events.includes("all") ? __spreadArrays(allEvents) : events;
    subscriptionEvents = subscriptionEvents.filter(function (action) {
        var subscriptionKey = JSON.stringify(buildSubscriptionArgument([action], setName, setType));
        var observers = messageSubscriptions.get(subscriptionKey);
        if (observers) {
            messageSubscriptions.set(subscriptionKey, __spreadArrays(observers, [observer]));
            return false;
        }
        else {
            messageSubscriptions.set(subscriptionKey, [observer]);
            return true;
        }
    });
    if (!subscriptionEvents.length) {
        return Promise.resolve();
    }
    if (allEvents.every(function (e) { return subscriptionEvents.includes(e); })) {
        subscriptionEvents = ["all"];
    }
    return realTimeCommand(webSocket, buildSubscriptionCommand(RealTimeCommandTypes.Subscribe, buildSubscriptionArgument(subscriptionEvents, setName, setType)));
}
export function unsubscribeEventMessage(webSocket, events, setName, setType, observer) {
    var unsubscribeEvents = events;
    if (observer) {
        var subscriptionEvents = events.includes("all") ? allEvents : events;
        unsubscribeEvents = subscriptionEvents.filter(function (action) {
            var subscriptionKey = JSON.stringify(buildSubscriptionArgument([action], setName, setType));
            var observers = (messageSubscriptions.get(subscriptionKey) || []).filter(function (o) { return o !== observer; });
            if (observers.length) {
                messageSubscriptions.set(subscriptionKey, observers);
                return false;
            }
            else {
                messageSubscriptions.delete(subscriptionKey);
                return true;
            }
        });
        if (!unsubscribeEvents.length) {
            return Promise.resolve();
        }
        if (allEvents.every(function (e) { return unsubscribeEvents.includes(e); })) {
            unsubscribeEvents = ["all"];
        }
    }
    return realTimeCommand(webSocket, buildSubscriptionCommand(RealTimeCommandTypes.UnSubscribe, buildSubscriptionArgument(unsubscribeEvents, setName, setType)));
}
function buildSubscriptionArgument(action, name, type) {
    return {
        action: action,
        resource: {
            type: type,
            name: name,
        },
    };
}
function buildSubscriptionCommand(command, commandArgument) {
    return {
        command: command,
        arguments: commandArgument,
    };
}
export function realTimeCommand(webSocket, data) {
    return new Promise(function (resolve, reject) {
        var requestCommand = { type: RealTimeMessageTypes.Command, data: data };
        responseStack.set(JSON.stringify(requestCommand), function (_a) {
            var error = _a.error, response = __rest(_a, ["error"]);
            error ? reject(parseError(error)) : resolve(response);
        });
        sendMessage(webSocket, requestCommand);
    });
}
function sendMessage(webSocket, message) {
    try {
        webSocket.send(JSON.stringify(message));
    }
    catch (error) {
        if (error.message === MESSAGE.RTC.NOT_OPEN_ERROR) {
            throw new Error(MESSAGE.RTC.NOT_OPEN_MESSAGE);
        }
        throw new Error(error);
    }
}
function parseError(error) {
    if (error.hasOwnProperty("code")) {
        var _a = error, code = _a.code, info = _a.info;
        return new Error("Subscription Error: (" + code + "): " + info);
    }
    return error;
}
