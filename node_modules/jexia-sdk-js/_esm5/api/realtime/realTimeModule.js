import { API, MESSAGE } from "../../config";
import { RequestExecuter } from "../../internal/executer";
import { AuthOptions, TokenManager } from "../core/tokenManager";
import { Dataset } from "../dataops/dataset";
import { Fileset } from "../fileops/fileset";
import { Channel } from "./channel";
import { WebSocketState } from "./realTime.interfaces";
import { watch } from "./watch";
import * as websocket from "./websocket";
var RTCResources = [Dataset, Fileset];
var RealTimeModule = (function () {
    function RealTimeModule(websocketBuilder) {
        this.websocketBuilder = websocketBuilder;
    }
    RealTimeModule.prototype.init = function (coreInjector) {
        var _this = this;
        this.injector = coreInjector.resolveAndCreateChild([
            RequestExecuter,
        ]);
        var tokenManager = coreInjector.get(TokenManager);
        var projectID = coreInjector.get(AuthOptions).projectID;
        RTCResources.forEach(function (resource) { return resource.prototype.watch = watch; });
        return tokenManager.token().toPromise().then(function (token) {
            try {
                _this.websocket = _this.websocketBuilder(_this.buildSocketOpenUri(projectID, token));
            }
            catch (error) {
                throw new Error(MESSAGE.RTC.ERROR_CREATING_WEBSOCKET + " Original error: " + error.message);
            }
            if (!_this.websocket) {
                throw new Error(MESSAGE.RTC.BAD_WEBSOCKET_CREATION_CALLBACK);
            }
            RTCResources.forEach(function (resource) { return resource.prototype.webSocket = _this.websocket; });
            return new Promise(function (resolve, reject) {
                _this.websocket.onopen = resolve;
                _this.websocket.onerror = function () { return reject(new Error(MESSAGE.RTC.CONNECTION_FAILED)); };
            });
        })
            .then(function () { return websocket.start(_this.websocket, function () { return tokenManager.token().toPromise(); }); })
            .then(function () { return _this; });
    };
    RealTimeModule.prototype.getConfig = function () {
        return { rtc: {} };
    };
    RealTimeModule.prototype.channel = function (name) {
        var _this = this;
        return new Channel(this.injector, function () { return _this.websocket; }, name);
    };
    RealTimeModule.prototype.terminate = function () {
        var _this = this;
        if (this.websocket.readyState === WebSocketState.CLOSED) {
            return Promise.resolve(this);
        }
        return new Promise(function (resolve, reject) {
            _this.websocket.onclose = function () { return resolve(_this); };
            _this.websocket.onerror = function (err) { return reject(err); };
            _this.websocket.close();
        });
    };
    RealTimeModule.prototype.buildSocketOpenUri = function (projectID, token) {
        var result = API.REAL_TIME.PROTOCOL + "://" + projectID + "." + API.HOST + "." + API.DOMAIN +
            ("" + (API.REAL_TIME.PORT || "") + API.REAL_TIME.ENDPOINT + "?access_token=" + token);
        return result;
    };
    return RealTimeModule;
}());
export { RealTimeModule };
