var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { toFilteringCriterion } from "../api/core/filteringApi";
import { MESSAGE } from "../config";
import { toQueryParams } from "./utils";
export class Query {
    constructor() {
        this.fields = [];
        this.orders = [];
    }
    setFilterCriteria(filter) {
        this.filteringConditions = toFilteringCriterion(filter).condition;
    }
    addSortCondition(direction, ...fields) {
        if (fields.length === 0) {
            throw new Error(MESSAGE.QUERY.MUST_PROVIDE_SORTING_FIELD);
        }
        this.orders.push({ fields, direction });
    }
    setAction(action, actionResource, filter) {
        this.actionParams = { action, actionResource, filter };
    }
    compile() {
        const compiledQueryOptions = {};
        if (this.filteringConditions) {
            compiledQueryOptions.cond = this.filteringConditions.compile();
        }
        if (this.limit || this.offset) {
            compiledQueryOptions.range = Object.assign(Object.assign({}, this.limit ? { limit: this.limit } : {}), this.offset ? { offset: this.offset } : {});
        }
        if (this.fields.length) {
            compiledQueryOptions.outputs = this.fields.map((field) => typeof field === "object" ? this.compileAggregation(field) : field);
        }
        if (this.orders.length) {
            compiledQueryOptions.order = this.orders;
        }
        if (this.actionParams) {
            const { action, actionResource, filter } = this.actionParams;
            compiledQueryOptions.action = action;
            compiledQueryOptions.action_resource = actionResource;
            compiledQueryOptions.action_cond = toFilteringCriterion(filter).condition.compile();
        }
        return compiledQueryOptions;
    }
    compileToQueryParams() {
        const compiled = this.compile();
        const params = [];
        if (compiled.order) {
            params.push(...compiled.order.map((value) => ({ key: "order", value })));
        }
        const { order } = compiled, compiledWithNoOrder = __rest(compiled, ["order"]);
        return params.concat(toQueryParams(compiledWithNoOrder));
    }
    compileAggregation(agg) {
        if (agg.fn === "count" && agg.field === "*") {
            agg.field = "id";
        }
        else if (agg.field === "*") {
            throw new Error(`Field name should be provided with the ${agg.fn}() function`);
        }
        return { [agg.alias || agg.fn]: `${agg.fn}(${agg.field})` };
    }
}
