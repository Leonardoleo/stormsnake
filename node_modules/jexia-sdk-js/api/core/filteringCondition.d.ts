export interface ICondition {
    readonly isSingle: boolean;
    type: LogicalOperator;
    or(condition: ICondition): ICondition;
    and(condition: ICondition): ICondition;
    compile(): any[];
}
export declare type LogicalOperator = "and" | "or";
export declare class FilteringCondition<U> implements ICondition {
    readonly field: string;
    readonly operator: string;
    readonly value: U[] | U;
    readonly isSingle = true;
    private logicalOperatorType;
    constructor(field: string, operator: string, value: U[] | U);
    type: LogicalOperator;
    or(condition: ICondition): CompositeFilteringCondition;
    and(condition: ICondition): CompositeFilteringCondition;
    compile(): (string | U | U[] | {
        field: string;
    })[];
}
export declare class CompositeFilteringCondition implements ICondition {
    readonly isSingle = false;
    private logicalOperatorType;
    private conditions;
    constructor(filteringCondition: ICondition, logicalOperatorType: LogicalOperator);
    type: LogicalOperator;
    or(condition: ICondition): CompositeFilteringCondition;
    and(condition: ICondition): CompositeFilteringCondition;
    compile(): any[];
    private toCompiledConditions;
    private appendCondition;
}
