import { ICondition } from "./filteringCondition";
import { ResourceInterface } from "./resource";
export declare class FieldFilter<U> {
    readonly fieldName: string;
    constructor(fieldName: string);
    isGreaterThan(value: U): IFilteringCriterion;
    isLessThan(value: U): IFilteringCriterion;
    isEqualTo(value: U): IFilteringCriterion;
    isDifferentFrom(value: U): IFilteringCriterion;
    isEqualOrGreaterThan(value: U): IFilteringCriterion;
    isEqualOrLessThan(value: U): IFilteringCriterion;
    isNull(): IFilteringCriterion;
    isNotNull(): IFilteringCriterion;
    isInArray(values: U[]): IFilteringCriterion;
    isNotInArray(values: U[]): IFilteringCriterion;
    isLike(value: string): IFilteringCriterion;
    satisfiesRegexp(regexp: string): IFilteringCriterion;
    isBetween(start: U, end: U): IFilteringCriterion;
}
export declare class FilteringCriterion implements IFilteringCriterion {
    private lowLevelCondition;
    constructor(lowLevelCondition?: ICondition, highLevelCriteria?: FilteringCriterion);
    readonly condition: ICondition;
    and(conditionToAdd: FilteringCriterion): FilteringCriterion;
    or(conditionToAdd: FilteringCriterion): FilteringCriterion;
}
export interface IFilteringCriterion<T = any> {
    readonly condition: ICondition;
    and(conditionToAdd: IFilteringCriterion<T>): IFilteringCriterion<T>;
    or(conditionToAdd: IFilteringCriterion<T>): IFilteringCriterion<T>;
}
export declare function field<T = ResourceInterface<any>, K extends Extract<keyof ResourceInterface<T>, string> = any>(name: K): FieldFilter<ResourceInterface<T>[K]>;
export declare type IFilteringCriterionCallback<T> = (filter: <K extends Extract<keyof T, string>>(field: K) => FieldFilter<T[K]>) => IFilteringCriterion<T>;
export declare function combineCriteria(criteria: IFilteringCriterion): IFilteringCriterion;
export declare function toFilteringCriterion<T>(filter: IFilteringCriterion<T> | IFilteringCriterionCallback<T>): IFilteringCriterion<T>;
